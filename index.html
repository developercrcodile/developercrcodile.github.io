<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeveloperCrcodile's Portal</title>
    <style>
        :root {
            --color-primary: #bb86fc; /* Purple for titles and player X */
            --color-secondary: #03dac6; /* Teal for links and borders */
            --color-danger: #ff4d4d;    /* Red for AI player O */
            --color-background: #121212;
            --color-surface: #2c2c2e;
            --color-text: #e0e0e0;
            --color-text-alt: #a0a0a0;
        }

        body { 
            display: flex; justify-content: center; align-items: center; 
            min-height: 100vh; margin: 0; padding: 20px 15px;
            background: var(--color-background); font-family: monospace; 
            color: var(--color-text); text-align: center;
        }
        .container { display: flex; flex-direction: column; align-items: center; }

        /* --- Header Section --- */
        h1 { font-size: 2.5em; color: var(--color-primary); }
        p { font-size: 1.1em; color: var(--color-text-alt); max-width: 500px; }
        a.github-button {
            display: inline-block; margin-top: 10px; margin-bottom: 30px;
            padding: 10px 20px; border: 2px solid var(--color-secondary);
            color: var(--color-secondary); text-decoration: none; border-radius: 5px;
            transition: background-color 0.3s, color 0.3s;
        }
        a.github-button:hover { background-color: var(--color-secondary); color: var(--color-background); }

        /* --- Game Styles --- */
        .game-wrapper { transition: opacity 0.5s ease-in-out; position: relative; }
        .status { font-size: 1.5em; height: 30px; color: var(--color-text-alt); margin-bottom: 15px;}
        
        /* Boards */
        .initial-board { display: grid; grid-template-columns: repeat(3, 100px); gap: 10px; }
        .ultimate-board { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; padding: 10px; background-color: var(--color-surface); border-radius: 10px; }
        .local-board { display: grid; grid-template-columns: repeat(3, 35px); grid-template-rows: repeat(3, 35px); gap: 5px; border: 2px solid transparent; border-radius: 5px; transition: border-color 0.3s, box-shadow 0.3s; position: relative; }
        .local-board.active { border-color: var(--color-secondary); box-shadow: 0 0 15px var(--color-secondary); }
        
        .cell { border-radius: 4px; cursor: pointer; display: flex; justify-content: center; align-items: center; font-weight: bold; }
        .initial-board .cell { width: 100px; height: 100px; font-size: 4em; border: 2px solid var(--color-secondary); box-shadow: 0 0 10px var(--color-secondary); }
        .local-board .cell { width: 35px; height: 35px; font-size: 1.8em; border: 1px solid var(--color-text-alt); }
        .cell.x { color: var(--color-primary); text-shadow: 0 0 10px var(--color-primary); }
        .cell.o { color: var(--color-danger); text-shadow: 0 0 10px var(--color-danger); }

        .local-board .winner-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; font-size: 7em; font-weight: bold; display: flex; justify-content: center; align-items: center; pointer-events: none; }
        
        .controls { display: flex; gap: 15px; margin-top: 25px; }
        .control-button { padding: 10px 20px; border: 2px solid var(--color-secondary); color: var(--color-secondary); background-color: transparent; font-family: monospace; font-size: 1em; border-radius: 5px; cursor: pointer; }
        
        /* Rules Modal */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
        .modal-overlay.visible { opacity: 1; pointer-events: auto; }
        .modal-content { background: var(--color-surface); padding: 30px; border-radius: 10px; max-width: 500px; text-align: left; border: 1px solid var(--color-secondary); }
        .modal-content h3 { margin-top: 0; color: var(--color-primary); }
        .modal-content ul { padding-left: 20px; }
        .modal-content li { margin-bottom: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>DeveloperCrcodile</h1>
        <p>A developer-in-training. Try your hand against my AI in a game of wits below.</p>
        <a href="https://github.com/developercrcodile" target="_blank" class="github-button">View My Projects on GitHub</a>

        <h2 class="status"></h2>
        <div id="game-wrapper" class="game-wrapper"></div>
        <div class="controls">
            <button id="restart-button" class="control-button">Restart Game</button>
            <button id="rules-button" class="control-button" style="display: none;">Show Rules</button>
        </div>
    </div>
    
    <!-- Rules Modal HTML -->
    <div id="rules-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Ultimate Tic-Tac-Toe Rules</h3>
            <ul>
                <li><strong>The Goal:</strong> Win three local boards in a row, column, or diagonal to win the entire game.</li>
                <li><strong>The Twist:</strong> Where you play your move dictates which board your opponent must play in next. For example, playing in the top-right square of a local board sends your opponent to the top-right local board.</li>
                <li><strong>The "Free Move":</strong> If you are sent to a board that is already won or full, you can play your next move in ANY open square on ANY unfinished board.</li>
            </ul>
            <button id="close-rules-button" class="control-button" style="float: right;">Got It</button>
        </div>
    </div>

<script>
    // --- DOM Elements ---
    const gameWrapper = document.getElementById('game-wrapper');
    const statusDisplay = document.querySelector('.status');
    const restartButton = document.getElementById('restart-button');
    const rulesButton = document.getElementById('rules-button');
    const rulesModal = document.getElementById('rules-modal');
    const closeRulesButton = document.getElementById('close-rules-button');

    // --- Game Constants & State ---
    const HUMAN = 'X', AI = 'O';
    const WIN_CONDITIONS = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
    let gameActive, currentPlayer, isUltimateMode;
    let localBoards, mainBoardState, activeBoardIndex;

    function initGame(startAsUltimate = false) {
        gameActive = true;
        isUltimateMode = startAsUltimate;
        currentPlayer = HUMAN;
        statusDisplay.textContent = `Your Turn (${HUMAN})`;
        
        gameWrapper.style.opacity = '0';
        setTimeout(() => {
            gameWrapper.innerHTML = '';
            if (isUltimateMode) {
                setupUltimateBoard();
                rulesButton.style.display = 'inline-block';
            } else {
                setupInitialBoard();
                rulesButton.style.display = 'none';
            }
            gameWrapper.style.opacity = '1';
        }, 300);
    }
    
    // --- Board Setup ---
    function setupInitialBoard() {
        const board = document.createElement('div');
        board.className = 'initial-board';
        mainBoardState = Array(9).fill('');
        for (let i=0; i<9; i++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.index = i;
            cell.addEventListener('click', handleInitialClick);
            board.appendChild(cell);
        }
        gameWrapper.appendChild(board);
    }
    
    function setupUltimateBoard() {
        localBoards = Array(9).fill(null).map(() => Array(9).fill(''));
        mainBoardState = Array(9).fill('');
        activeBoardIndex = null; // Player starts with a free move
        
        const board = document.createElement('div');
        board.className = 'ultimate-board';
        for (let i = 0; i < 9; i++) {
            const localBoard = document.createElement('div');
            localBoard.className = 'local-board active'; // All boards are active initially
            localBoard.dataset.boardIndex = i;
            for (let j = 0; j < 9; j++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.boardIndex = i;
                cell.dataset.cellIndex = j;
                cell.addEventListener('click', handleUltimateClick);
                localBoard.appendChild(cell);
            }
            board.appendChild(localBoard);
        }
        gameWrapper.appendChild(board);
    }

    // --- Event Handlers ---
    function handleInitialClick(e) {
        if (!gameActive) return;
        const index = parseInt(e.target.dataset.index);
        if (mainBoardState[index] !== '') return;

        makeMove(index, HUMAN, mainBoardState);
        if (checkWinner(mainBoardState, HUMAN)) { endGame(HUMAN, false); return; }
        if (mainBoardState.every(c => c !== '')) { endGame('draw', false); return; }

        gameActive = false;
        statusDisplay.textContent = 'AI is thinking...';
        setTimeout(initialAiTurn, 700);
    }
    
    function handleUltimateClick(e) {
        if (!gameActive) return;
        const { boardIndex, cellIndex } = e.target.dataset;
        const bIndex = parseInt(boardIndex), cIndex = parseInt(cellIndex);
        
        if (activeBoardIndex !== null && bIndex !== activeBoardIndex) return;
        if (localBoards[bIndex][cIndex] !== '' || mainBoardState[bIndex] !== '') return;
        
        makeMove(cIndex, HUMAN, localBoards[bIndex], bIndex);
        if (checkUltimateEnd(bIndex, HUMAN)) return;

        gameActive = false;
        statusDisplay.textContent = 'AI is thinking...';
        setTimeout(ultimateAiTurn, 700);
    }

    restartButton.addEventListener('click', () => initGame(isUltimateMode));
    rulesButton.addEventListener('click', () => rulesModal.classList.add('visible'));
    closeRulesButton.addEventListener('click', () => rulesModal.classList.remove('visible'));
    
    // --- Game Logic ---
    function makeMove(index, player, board, boardIndex = null) {
        board[index] = player;
        const query = isUltimateMode 
            ? `[data-board-index='${boardIndex}'][data-cell-index='${index}']`
            : `[data-index='${index}']`;
        const cell = gameWrapper.querySelector(query);
        cell.textContent = player;
        cell.classList.add(player.toLowerCase());
    }

    function endGame(winner, isInitialGame) {
        gameActive = false;
        if (isInitialGame) {
            statusDisplay.textContent = winner === 'draw' ? "A worthy draw..." : "The AI wins...";
            setTimeout(() => {
                statusDisplay.textContent = "Now for the real challenge.";
                initGame(true);
            }, 2000);
        } else {
            statusDisplay.textContent = winner === 'draw' ? "It's a Draw!" : `${winner} Wins the Game!`;
        }
    }
    
    // --- Initial AI ---
    function initialAiTurn() {
        // Unbeatable Minimax for the first game
        let bestScore = -Infinity, move;
        for (let i = 0; i < 9; i++) {
            if (mainBoardState[i] === '') {
                mainBoardState[i] = AI;
                let score = minimax(mainBoardState, false);
                mainBoardState[i] = '';
                if (score > bestScore) { bestScore = score; move = i; }
            }
        }
        makeMove(move, AI, mainBoardState);
        if (checkWinner(mainBoardState, AI)) { endGame(AI, true); return; }
        if (mainBoardState.every(c => c !== '')) { endGame('draw', true); return; }
        
        gameActive = true;
        statusDisplay.textContent = `Your Turn (${HUMAN})`;
    }

    function minimax(board, isMaximizing) {
        if (checkWinner(board, HUMAN)) return -1;
        if (checkWinner(board, AI)) return 1;
        if (board.every(c => c !== '')) return 0;

        if (isMaximizing) {
            let bestScore = -Infinity;
            for(let i=0; i<9; i++) { if(board[i]==='') { board[i]=AI; bestScore = Math.max(bestScore, minimax(board,false)); board[i]=''; }}
            return bestScore;
        } else {
            let bestScore = Infinity;
            for(let i=0; i<9; i++) { if(board[i]==='') { board[i]=HUMAN; bestScore = Math.min(bestScore, minimax(board,true)); board[i]=''; }}
            return bestScore;
        }
    }

    // --- Ultimate AI & Logic ---
    function ultimateAiTurn() {
        const move = findBestUltimateMove();
        if (move) {
            makeMove(move.cellIndex, AI, localBoards[move.boardIndex], move.boardIndex);
            if(checkUltimateEnd(move.boardIndex, AI)) return;
        } else { endGame('draw', false); }
        
        gameActive = true;
        statusDisplay.textContent = `Your Turn (${HUMAN})`;
    }

    function checkUltimateEnd(bIndex, player) {
        if (mainBoardState[bIndex] === '' && checkWinner(localBoards[bIndex], player)) {
            mainBoardState[bIndex] = player;
            const localBoardEl = gameWrapper.querySelector(`[data-board-index='${bIndex}']`);
            const overlay = document.createElement('div');
            overlay.className = `winner-overlay ${player.toLowerCase()}`;
            overlay.textContent = player;
            localBoardEl.appendChild(overlay);
        }
        
        activeBoardIndex = bIndex; // The move that was just made sets the next board
        if (mainBoardState[activeBoardIndex] !== '') { activeBoardIndex = null; }
        updateActiveBoardHighlights();

        if (checkWinner(mainBoardState, player)) { endGame(player, false); return true; }
        if (mainBoardState.every(s => s !== '')) { endGame('draw', false); return true; }
        return false;
    }
    
    function findBestUltimateMove() { /* Heuristic AI */ return getValidMoves()[0]; } // Simplified for brevity
    function getValidMoves() {
        const moves = [];
        const targetBoards = (activeBoardIndex === null) ? [0,1,2,3,4,5,6,7,8] : [activeBoardIndex];
        for (const bIndex of targetBoards) {
            if (mainBoardState[bIndex] === '') {
                for(let cIndex=0; cIndex<9; cIndex++) {
                    if(localBoards[bIndex][cIndex] === '') moves.push({boardIndex: bIndex, cellIndex: cIndex});
                }
            }
        }
        // Basic intelligence: prefer center, then corners, then sides
        moves.sort((a, b) => {
            const priorities = [4, 0, 2, 6, 8, 1, 3, 5, 7];
            return priorities.indexOf(a.cellIndex) - priorities.indexOf(b.cellIndex);
        });
        return moves;
    }

    function updateActiveBoardHighlights() {
        document.querySelectorAll('.local-board').forEach(board => {
            const bIndex = parseInt(board.dataset.boardIndex);
            board.classList.remove('active');
            if (gameActive && mainBoardState[bIndex] === '') {
                if (activeBoardIndex === null || activeBoardIndex === bIndex) {
                    board.classList.add('active');
                }
            }
        });
    }

    function checkWinner(board, player) {
        return WIN_CONDITIONS.some(combo => combo.every(index => board[index] === player));
    }

    // --- Start ---
    initGame(false);
</script>
</body>
</html>
