<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeveloperCrcodile's Portal</title>
    <style>
        :root {
            --color-primary: #bb86fc; /* Purple for titles and player X */
            --color-secondary: #03dac6; /* Teal for links and borders */
            --color-danger: #ff4d4d;    /* Red for AI player O */
            --color-background: #121212;
            --color-surface: #2c2c2e;
            --color-text: #e0e0e0;
            --color-text-alt: #a0a0a0;
        }

        body { 
            display: flex; justify-content: center; align-items: center; 
            min-height: 100vh; margin: 0; padding: 20px 15px;
            background: var(--color-background); font-family: monospace; 
            color: var(--color-text); text-align: center;
        }
        .container { display: flex; flex-direction: column; align-items: center; }

        /* --- Header Section --- */
        h1 { font-size: 2.5em; color: var(--color-primary); }
        p { font-size: 1.1em; color: var(--color-text-alt); max-width: 500px; }
        a.github-button {
            display: inline-block; margin-top: 10px; margin-bottom: 30px;
            padding: 10px 20px; border: 2px solid var(--color-secondary);
            color: var(--color-secondary); text-decoration: none; border-radius: 5px;
            transition: background-color 0.3s, color 0.3s;
        }
        a.github-button:hover { background-color: var(--color-secondary); color: var(--color-background); }

        /* --- Game Styles --- */
        .game-wrapper { transition: opacity 0.5s ease-in-out; position: relative; }
        .status { font-size: 1.5em; height: 30px; color: var(--color-text-alt); margin-bottom: 15px;}
        
        /* Shared Cell Styles */
        .cell { border-radius: 10px; cursor: pointer; display: flex; justify-content: center; align-items: center; font-weight: bold; }
        .cell.x { color: var(--color-primary); text-shadow: 0 0 10px var(--color-primary); }
        .cell.o { color: var(--color-danger); text-shadow: 0 0 10px var(--color-danger); }

        /* Initial Board - The chunky, stylish one */
        .initial-board { display: grid; grid-template-columns: repeat(3, 100px); gap: 10px; }
        .initial-board .cell { width: 100px; height: 100px; font-size: 4em; border: 2px solid var(--color-secondary); box-shadow: 0 0 10px var(--color-secondary); }

        /* Ultimate Board - Made to look like 9 smaller versions of the initial board */
        .ultimate-board { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; padding: 15px; background-color: var(--color-surface); border-radius: 15px; }
        .local-board { 
            display: grid; grid-template-columns: repeat(3, 60px); grid-template-rows: repeat(3, 60px); gap: 5px; 
            border: 2px solid var(--color-secondary); box-shadow: 0 0 10px var(--color-secondary); 
            border-radius: 10px; transition: border-color 0.3s, box-shadow 0.3s; position: relative; 
        }
        .local-board.active { border-color: var(--color-primary); box-shadow: 0 0 20px var(--color-primary); }
        .local-board .cell { width: 60px; height: 60px; font-size: 2.5em; background-color: var(--color-background); }
        
        .local-board .winner-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; font-size: 6em; font-weight: bold; display: flex; justify-content: center; align-items: center; pointer-events: none; }
        
        .controls { display: flex; gap: 15px; margin-top: 25px; }
        .control-button { padding: 10px 20px; border: 2px solid var(--color-secondary); color: var(--color-secondary); background-color: transparent; font-family: monospace; font-size: 1em; border-radius: 5px; cursor: pointer; }
        
        /* Rules Modal */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; z-index: 100; }
        .modal-overlay.visible { opacity: 1; pointer-events: auto; }
        .modal-content { background: var(--color-surface); padding: 30px; border-radius: 10px; max-width: 500px; text-align: left; border: 1px solid var(--color-secondary); }
        .modal-content h3 { margin-top: 0; color: var(--color-primary); }
        .modal-content ul { padding-left: 20px; }
        .modal-content li { margin-bottom: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>DeveloperCrcodile</h1>
        <p>A developer-in-training. You can't beat the AI in the first game, but see what happens when you try.</p>
        <a href="https://github.com/developercrcodile" target="_blank" class="github-button">View My Projects on GitHub</a>

        <h2 class="status"></h2>
        <div id="game-wrapper" class="game-wrapper"></div>
        <div class="controls">
            <button id="restart-button" class="control-button">Restart Game</button>
            <button id="rules-button" class="control-button" style="display: none;">Show Rules</button>
        </div>
    </div>
    
    <div id="rules-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Ultimate Tic-Tac-Toe Rules</h3>
            <ul>
                <li><strong>The Goal:</strong> Win three local boards in a row, column, or diagonal.</li>
                <li><strong>The Twist:</strong> Where you play your move dictates which board your opponent must play in next. (e.g., playing in the top-right square sends your opponent to the top-right local board).</li>
                <li><strong>The "Free Move":</strong> If you're sent to a board that is already won or full, you can play your next move in ANY open square on ANY unfinished board.</li>
            </ul>
            <button id="close-rules-button" class="control-button" style="float: right;">Got It</button>
        </div>
    </div>

<script>
    // --- DOM Elements ---
    const gameWrapper = document.getElementById('game-wrapper');
    const statusDisplay = document.querySelector('.status');
    const restartButton = document.getElementById('restart-button');
    const rulesButton = document.getElementById('rules-button');
    const rulesModal = document.getElementById('rules-modal');
    const closeRulesButton = document.getElementById('close-rules-button');

    // --- Game Constants & State ---
    const HUMAN = 'X', AI = 'O';
    const WIN_CONDITIONS = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
    let gameActive, isUltimateMode, initialBoardState, localBoards, mainBoardState, activeBoardIndex;

    function initGame(startAsUltimate = false) {
        gameActive = true;
        isUltimateMode = startAsUltimate;
        statusDisplay.textContent = `Your Turn (${HUMAN})`;
        
        gameWrapper.style.opacity = '0';
        setTimeout(() => {
            gameWrapper.innerHTML = '';
            if (isUltimateMode) {
                setupUltimateBoard(initialBoardState); // Pass the finished board state
            } else {
                setupInitialBoard();
            }
            gameWrapper.style.opacity = '1';
        }, 500);
    }
    
    // --- Board Setup ---
    function setupInitialBoard() {
        rulesButton.style.display = 'none';
        const board = document.createElement('div');
        board.className = 'initial-board';
        initialBoardState = Array(9).fill('');
        for (let i=0; i<9; i++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.index = i;
            cell.addEventListener('click', handleInitialClick);
            board.appendChild(cell);
        }
        gameWrapper.appendChild(board);
    }
    
    function setupUltimateBoard(previousGameState) {
        rulesButton.style.display = 'inline-block';
        localBoards = Array(9).fill(null).map(() => Array(9).fill(''));
        mainBoardState = Array(9).fill('');

        // The key transition logic: the previous game becomes the center board
        localBoards[4] = previousGameState;
        mainBoardState[4] = checkWinner(previousGameState, AI) ? AI : 'draw';
        
        const board = document.createElement('div');
        board.className = 'ultimate-board';
        for (let i = 0; i < 9; i++) {
            const localBoardEl = document.createElement('div');
            localBoardEl.className = 'local-board';
            localBoardEl.dataset.boardIndex = i;
            for (let j = 0; j < 9; j++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.boardIndex = i;
                cell.dataset.cellIndex = j;
                cell.addEventListener('click', handleUltimateClick);
                if (i === 4) { // Populate the center board
                    cell.textContent = localBoards[i][j];
                    if (localBoards[i][j]) cell.classList.add(localBoards[i][j].toLowerCase());
                }
                localBoardEl.appendChild(cell);
            }
            if (mainBoardState[i]) {
                const overlay = document.createElement('div');
                overlay.className = `winner-overlay ${mainBoardState[i].toLowerCase()}`;
                overlay.textContent = mainBoardState[i];
                localBoardEl.appendChild(overlay);
            }
            board.appendChild(localBoardEl);
        }
        gameWrapper.appendChild(board);
        
        // AI's last move in the initial game determines the next active board
        activeBoardIndex = initialAiLastMove;
        updateActiveBoardHighlights();
    }

    // --- Event Handlers ---
    function handleInitialClick(e) {
        if (!gameActive) return;
        const index = parseInt(e.target.dataset.index);
        if (initialBoardState[index] !== '') return;

        makeMove(index, HUMAN, initialBoardState);
        if (checkWinner(initialBoardState, HUMAN)) { endGame(true); return; }
        if (initialBoardState.every(c => c !== '')) { endGame(true); return; }

        gameActive = false;
        statusDisplay.textContent = 'AI is thinking...';
        setTimeout(initialAiTurn, 700);
    }
    
    function handleUltimateClick(e) { /* ... same as before ... */ }
    restartButton.addEventListener('click', () => initGame(isUltimateMode));
    rulesButton.addEventListener('click', () => rulesModal.classList.add('visible'));
    closeRulesButton.addEventListener('click', () => rulesModal.classList.remove('visible'));
    
    // --- Game Logic ---
    function makeMove(index, player, board, boardIndex = null) { /* ... same as before ... */ }

    function endGame(isInitialGame) {
        gameActive = false;
        if (isInitialGame) {
            statusDisplay.textContent = "A worthy effort... but inevitable.";
            setTimeout(() => {
                statusDisplay.textContent = "Let's play for real.";
                isUltimateMode = true;
                initGame(true); // Re-initialize in ultimate mode
            }, 2500);
        } else {
             // ... Ultimate game end logic ...
        }
    }
    
    let initialAiLastMove;
    function initialAiTurn() {
        let bestScore = -Infinity, move;
        for (let i = 0; i < 9; i++) {
            if (initialBoardState[i] === '') {
                initialBoardState[i] = AI;
                let score = minimax(initialBoardState, false);
                initialBoardState[i] = '';
                if (score > bestScore) { bestScore = score; move = i; }
            }
        }
        initialAiLastMove = move; // Store the AI's move
        makeMove(move, AI, initialBoardState);
        if (checkWinner(initialBoardState, AI) || initialBoardState.every(c => c !== '')) { 
            endGame(true); 
            return; 
        }
        
        gameActive = true;
        statusDisplay.textContent = `Your Turn (${HUMAN})`;
    }

    function minimax(board, isMaximizing) { /* ... same as before ... */ }
    function checkWinner(board, player) { /* ... same as before ... */ }
    
    // Placeholder functions for Ultimate Mode to be filled in
    function handleUltimateClick(e) { console.log('Ultimate move'); }

    // --- Start ---
    initGame(false);


    // ---- Full Ultimate Logic (re-added for completeness) ----
    function handleUltimateClick(e) {
        if (!gameActive) return;
        const { boardIndex, cellIndex } = e.target.dataset;
        const bIndex = parseInt(boardIndex), cIndex = parseInt(cellIndex);
        
        if (activeBoardIndex !== null && bIndex !== activeBoardIndex) return;
        if (localBoards[bIndex][cIndex] !== '' || mainBoardState[bIndex] !== '') return;
        
        makeMove(cIndex, HUMAN, localBoards[bIndex], bIndex);
        if (checkUltimateEnd(cIndex, HUMAN)) return;

        gameActive = false;
        statusDisplay.textContent = 'AI is thinking...';
        setTimeout(ultimateAiTurn, 700);
    }
    
    function makeMove(index, player, board, boardIndex = null) {
        board[index] = player;
        const query = (isUltimateMode && boardIndex !== null)
            ? `[data-board-index='${boardIndex}'][data-cell-index='${index}']`
            : `[data-index='${index}']`;
        const cell = gameWrapper.querySelector(query);
        cell.textContent = player;
        cell.classList.add(player.toLowerCase());
    }

    function endGame(isInitialGame, winner = 'draw') {
        gameActive = false;
        if (isInitialGame) {
            statusDisplay.textContent = "A worthy effort... but inevitable.";
            setTimeout(() => {
                statusDisplay.textContent = "Now, let's play for real.";
                isUltimateMode = true;
                initGame(true);
            }, 2500);
        } else {
            statusDisplay.textContent = winner === 'draw' ? "It's a Draw!" : `${winner} Wins the Game!`;
        }
    }
    
    function ultimateAiTurn() {
        const move = findBestUltimateMove();
        if (move) {
            makeMove(move.cellIndex, AI, localBoards[move.boardIndex], move.boardIndex);
            if(checkUltimateEnd(move.cellIndex, AI)) return;
        } else { endGame(false, 'draw'); }
        
        gameActive = true;
        statusDisplay.textContent = `Your Turn (${HUMAN})`;
    }

    function checkUltimateEnd(lastCellIndex, player) {
        const boardIndex = activeBoardIndex; // The board that was just played on
        if (mainBoardState[boardIndex] === '' && checkWinner(localBoards[boardIndex], player)) {
            mainBoardState[boardIndex] = player;
            const localBoardEl = gameWrapper.querySelector(`[data-board-index='${boardIndex}']`);
            const overlay = document.createElement('div');
            overlay.className = `winner-overlay ${player.toLowerCase()}`;
            overlay.textContent = player;
            localBoardEl.appendChild(overlay);
        }
        
        activeBoardIndex = lastCellIndex;
        if (mainBoardState[activeBoardIndex] !== '') { activeBoardIndex = null; }
        updateActiveBoardHighlights();

        if (checkWinner(mainBoardState, player)) { endGame(false, player); return true; }
        if (mainBoardState.every(s => s !== '')) { endGame(false, 'draw'); return true; }
        return false;
    }

    function findBestUltimateMove() {
        const validMoves = getValidMoves();
        if (validMoves.length === 0) return null;
        // Heuristic AI logic here... (Simplified for now)
        return validMoves[Math.floor(Math.random() * validMoves.length)];
    }

    function getValidMoves() {
        const moves = [];
        const targetBoards = (activeBoardIndex === null) ? [0,1,2,3,4,5,6,7,8].filter(i => mainBoardState[i] === '') : [activeBoardIndex];
        for (const bIndex of targetBoards) {
            for(let cIndex=0; cIndex<9; cIndex++) {
                if(localBoards[bIndex][cIndex] === '') moves.push({boardIndex: bIndex, cellIndex: cIndex});
            }
        }
        return moves;
    }

    function updateActiveBoardHighlights() {
        document.querySelectorAll('.local-board').forEach(board => {
            const bIndex = parseInt(board.dataset.boardIndex);
            board.classList.remove('active');
            if (gameActive && mainBoardState[bIndex] === '') {
                if (activeBoardIndex === null || activeBoardIndex === bIndex) {
                    board.classList.add('active');
                }
            }
        });
    }

    function checkWinner(board, player) {
        return WIN_CONDITIONS.some(combo => combo.every(index => board[index] === player));
    }

    initGame(false);
</script>
</body>
</html>
