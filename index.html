<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeveloperCrcodile's Portal</title>
    <style>
        :root {
            --color-primary: #bb86fc; /* Purple for titles and player X */
            --color-secondary: #03dac6; /* Teal for links and borders */
            --color-danger: #ff4d4d;    /* Red for AI player O */
            --color-background: #121212;
            --color-surface: #2c2c2e;
        }

        body { 
            display: flex; justify-content: center; align-items: center; 
            min-height: 100vh; margin: 0; padding: 20px 15px;
            background: var(--color-background); font-family: monospace; 
            color: var(--color-text-alt); text-align: center;
        }
        .container { display: flex; flex-direction: column; align-items: center; }

        /* --- Header Section --- */
        h1 { font-size: 2.5em; color: var(--color-primary); }
        p { font-size: 1.1em; max-width: 500px; }
        a.github-button {
            display: inline-block; margin-top: 10px; margin-bottom: 30px;
            padding: 10px 20px; border: 2px solid var(--color-secondary);
            color: var(--color-secondary); text-decoration: none; border-radius: 5px;
        }

        /* --- Game Styles --- */
        .game-wrapper { transition: opacity 0.5s ease-in-out; position: relative; }
        .status { font-size: 1.5em; height: 30px; margin-bottom: 15px;}
        
        .cell { border-radius: 10px; cursor: pointer; display: flex; justify-content: center; align-items: center; font-weight: bold; }
        .cell.x { color: var(--color-primary); text-shadow: 0 0 10px var(--color-primary); }
        .cell.o { color: var(--color-danger); text-shadow: 0 0 10px var(--color-danger); }

        .initial-board { display: grid; grid-template-columns: repeat(3, 100px); gap: 10px; }
        .initial-board .cell { width: 100px; height: 100px; font-size: 4em; border: 2px solid var(--color-secondary); box-shadow: 0 0 10px var(--color-secondary); }

        .ultimate-board { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; }
        .local-board { 
            position: relative;
            display: grid; grid-template-columns: repeat(3, 60px); grid-template-rows: repeat(3, 60px); gap: 5px; 
            border-radius: 10px; 
            transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
        }
        /* NEW: Active board scaling */
        .local-board.active {
            transform: scale(1.08);
            z-index: 10;
            box-shadow: 0 0 25px var(--color-secondary);
        }
        .local-board .cell { width: 60px; height: 60px; font-size: 2.5em; background: var(--color-surface); }
        
        /* NEW: Winner overlay icon */
        .winner-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            font-size: 8em; font-weight: bold;
            display: flex; justify-content: center; align-items: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .local-board.won .winner-overlay { opacity: 1; }
        .local-board.won .cell { opacity: 0; }

        .controls { display: flex; gap: 15px; margin-top: 25px; }
        .control-button { padding: 10px 20px; border: 2px solid var(--color-secondary); color: var(--color-secondary); background-color: transparent; font-family: monospace; font-size: 1em; border-radius: 5px; cursor: pointer; }
        
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; z-index: 100; }
        .modal-overlay.visible { opacity: 1; pointer-events: auto; }
        .modal-content { background: var(--color-surface); padding: 30px; border-radius: 10px; max-width: 500px; text-align: left; border: 1px solid var(--color-secondary); }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header with description restored -->
        <h1>DeveloperCrcodile</h1>
        <p>A developer-in-training, exploring the world of self-hosting and servers. You can't beat the AI in the first game, but see what happens when you try.</p>
        <a href="https://github.com/DeveloperCrcodiles" target="_blank" class="github-button">View My Projects on GitHub</a>

        <h2 class="status"></h2>
        <div id="game-wrapper" class="game-wrapper"></div>
        <div class="controls">
            <button id="restart-button" class="control-button">Restart Game</button>
            <button id="rules-button" class="control-button" style="display: none;">Show Rules</button>
        </div>
    </div>
    
    <div id="rules-modal" class="modal-overlay"> <!-- Rules Modal HTML is unchanged --> </div>

<script>
    // --- All JavaScript logic from the previous version is here, with key updates ---
    const gameWrapper = document.getElementById('game-wrapper');
    const statusDisplay = document.querySelector('.status');
    const restartButton = document.getElementById('restart-button');
    const rulesButton = document.getElementById('rules-button');
    const rulesModal = document.getElementById('rules-modal');
    const closeRulesButton = document.getElementById('close-rules-button');

    const HUMAN = 'X', AI = 'O';
    const WIN_CONDITIONS = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
    let gameActive, isUltimateMode, initialBoardState, localBoards, mainBoardState, activeBoardIndex, initialAiLastMove;

    function initGame(startAsUltimate = false) {
        gameActive = true;
        isUltimateMode = startAsUltimate;
        statusDisplay.textContent = `Your Turn (${HUMAN})`;
        
        gameWrapper.style.opacity = '0';
        setTimeout(() => {
            gameWrapper.innerHTML = '';
            if (isUltimateMode) {
                setupUltimateBoard(initialBoardState);
            } else {
                setupInitialBoard();
            }
            gameWrapper.style.opacity = '1';
        }, 500);
    }
    
    function setupInitialBoard() { /* Unchanged */ }
    
    function setupUltimateBoard(previousGameState) {
        rulesButton.style.display = 'inline-block';
        localBoards = Array(9).fill(null).map(() => Array(9).fill(''));
        mainBoardState = Array(9).fill('');
        localBoards[4] = previousGameState;
        mainBoardState[4] = checkWinner(previousGameState, AI) ? AI : 'draw';
        
        const board = document.createElement('div');
        board.className = 'ultimate-board';
        for (let i = 0; i < 9; i++) {
            const localBoardEl = document.createElement('div');
            localBoardEl.className = 'local-board';
            localBoardEl.dataset.boardIndex = i;
            for (let j = 0; j < 9; j++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.boardIndex = i;
                cell.dataset.cellIndex = j;
                cell.addEventListener('click', handleUltimateClick);
                if (i === 4) {
                    cell.textContent = localBoards[i][j];
                    if (localBoards[i][j]) cell.classList.add(localBoards[i][j].toLowerCase());
                }
                localBoardEl.appendChild(cell);
            }
            // Add winner overlay if board is already won
            if (mainBoardState[i]) {
                handleLocalWin(localBoardEl, mainBoardState[i]);
            }
            board.appendChild(localBoardEl);
        }
        gameWrapper.appendChild(board);
        
        activeBoardIndex = initialAiLastMove;
        updateActiveBoardHighlights();
    }

    // NEW: Function to handle the visual state of a won local board
    function handleLocalWin(localBoardElement, winner) {
        localBoardElement.classList.add('won');
        const overlay = document.createElement('div');
        overlay.className = `winner-overlay ${winner.toLowerCase()}`;
        overlay.textContent = winner;
        localBoardElement.appendChild(overlay);
    }
    
    function updateActiveBoardHighlights() {
        document.querySelectorAll('.local-board').forEach(board => {
            const bIndex = parseInt(board.dataset.boardIndex);
            board.classList.remove('active'); // Remove scaling from all boards
            if (gameActive && mainBoardState[bIndex] === '') {
                if (activeBoardIndex === null || activeBoardIndex === bIndex) {
                    board.classList.add('active'); // Add scaling only to active ones
                }
            }
        });
    }

    function checkUltimateEnd(lastCellIndex, player) {
        const boardIndex = activeBoardIndex; 
        if (boardIndex === null || mainBoardState[boardIndex] !== '') return false;

        if (checkWinner(localBoards[boardIndex], player)) {
            mainBoardState[boardIndex] = player;
            handleLocalWin(gameWrapper.querySelector(`[data-board-index='${boardIndex}']`), player);
        }
        
        activeBoardIndex = lastCellIndex;
        if (activeBoardIndex === null || mainBoardState[activeBoardIndex] !== '') {
            activeBoardIndex = null;
        }
        updateActiveBoardHighlights();

        if (checkWinner(mainBoardState, player)) { endGame(false, player); return true; }
        if (mainBoardState.every(s => s !== '')) { endGame(false, 'draw'); return true; }
        return false;
    }
    
    /* The rest of the JS functions (initial game logic, AI, etc.) are unchanged */
    function setupInitialBoard() {
        rulesButton.style.display = 'none';
        const board = document.createElement('div');
        board.className = 'initial-board';
        initialBoardState = Array(9).fill('');
        for (let i=0; i<9; i++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.index = i;
            cell.addEventListener('click', handleInitialClick);
            board.appendChild(cell);
        }
        gameWrapper.appendChild(board);
    }
    function handleInitialClick(e) {
        if (!gameActive) return;
        const index = parseInt(e.target.dataset.index);
        if (initialBoardState[index] !== '') return;

        makeMove(index, HUMAN);
        if (checkWinner(initialBoardState, HUMAN)) { endGame(true); return; }
        if (initialBoardState.every(c => c !== '')) { endGame(true); return; }

        gameActive = false;
        statusDisplay.textContent = 'AI is thinking...';
        setTimeout(initialAiTurn, 700);
    }
    function makeMove(index, player, board = null, boardIndex = null) {
        if (isUltimateMode) {
            board = localBoards[boardIndex];
            board[index] = player;
            const cell = gameWrapper.querySelector(`[data-board-index='${boardIndex}'][data-cell-index='${index}']`);
            cell.textContent = player;
            cell.classList.add(player.toLowerCase());
        } else {
            board = initialBoardState;
            board[index] = player;
            const cell = gameWrapper.querySelector(`[data-index='${index}']`);
            cell.textContent = player;
            cell.classList.add(player.toLowerCase());
        }
    }
    function handleUltimateClick(e) {
        if (!gameActive) return;
        const { boardIndex, cellIndex } = e.target.dataset;
        const bIndex = parseInt(boardIndex), cIndex = parseInt(cellIndex);
        
        if (activeBoardIndex !== null && bIndex !== activeBoardIndex) return;
        if (localBoards[bIndex][cIndex] !== '' || mainBoardState[bIndex] !== '') return;
        
        makeMove(cIndex, HUMAN, null, bIndex);
        if (checkUltimateEnd(cIndex, HUMAN)) return;

        gameActive = false;
        statusDisplay.textContent = 'AI is thinking...';
        setTimeout(ultimateAiTurn, 700);
    }
    function initialAiTurn() {
        let bestScore = -Infinity, move;
        for (let i = 0; i < 9; i++) {
            if (initialBoardState[i] === '') {
                initialBoardState[i] = AI;
                let score = minimax(initialBoardState, false);
                initialBoardState[i] = '';
                if (score > bestScore) { bestScore = score; move = i; }
            }
        }
        initialAiLastMove = move;
        makeMove(move, AI);
        if (checkWinner(initialBoardState, AI) || initialBoardState.every(c => c !== '')) { 
            endGame(true); 
            return; 
        }
        gameActive = true;
        statusDisplay.textContent = `Your Turn (${HUMAN})`;
    }
    function minimax(board, isMaximizing) {
        if (checkWinner(board, HUMAN)) return -1;
        if (checkWinner(board, AI)) return 1;
        if (board.every(c => c !== '')) return 0;
        let bestScore = isMaximizing ? -Infinity : Infinity;
        for(let i=0; i<9; i++) {
            if(board[i]==='') {
                board[i]= isMaximizing ? AI : HUMAN;
                const score = minimax(board, !isMaximizing);
                board[i]='';
                bestScore = isMaximizing ? Math.max(score, bestScore) : Math.min(score, bestScore);
            }
        }
        return bestScore;
    }
    function endGame(isInitialGame, winner = 'draw') {
        gameActive = false;
        if (isInitialGame) {
            statusDisplay.textContent = "A worthy effort... but inevitable.";
            setTimeout(() => {
                statusDisplay.textContent = "Now, let's play for real.";
                isUltimateMode = true;
                initGame(true);
            }, 2500);
        } else {
            statusDisplay.textContent = winner === 'draw' ? "It's a Draw!" : `${winner} Wins the Game!`;
        }
    }
    function ultimateAiTurn() {
        const move = findBestUltimateMove();
        if (move) {
            makeMove(move.cellIndex, AI, null, move.boardIndex);
            if(checkUltimateEnd(move.cellIndex, AI)) return;
        } else { endGame(false, 'draw'); }
        
        gameActive = true;
        statusDisplay.textContent = `Your Turn (${HUMAN})`;
    }
    function findBestUltimateMove() {
        const moves = getValidMoves();
        if (moves.length === 0) return null;
        moves.sort((a, b) => {
            const priorities = [4, 0, 2, 6, 8, 1, 3, 5, 7];
            return priorities.indexOf(a.cellIndex) - priorities.indexOf(b.cellIndex);
        });
        return moves[0];
    }
    function getValidMoves() {
        const moves = [];
        const targetBoards = (activeBoardIndex === null) 
            ? [0,1,2,3,4,5,6,7,8].filter(i => mainBoardState[i] === '') 
            : [activeBoardIndex];
        for (const bIndex of targetBoards) {
            for(let cIndex=0; cIndex<9; cIndex++) {
                if(localBoards[bIndex][cIndex] === '') moves.push({boardIndex: bIndex, cellIndex: cIndex});
            }
        }
        return moves;
    }
    function checkWinner(board, player) {
        return WIN_CONDITIONS.some(combo => combo.every(index => board[index] === player));
    }
    restartButton.addEventListener('click', () => initGame(isUltimateMode));
    rulesButton.addEventListener('click', () => rulesModal.classList.add('visible'));
    closeRulesButton.addEventListener('click', () => rulesModal.classList.remove('visible'));
    initGame(false);
</script>
</body>
</html>
