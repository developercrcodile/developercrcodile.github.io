<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeveloperCrcodile's Portal</title>
    <style>
        :root {
            --color-primary: #bb86fc; /* Purple for titles and player X */
            --color-secondary: #03dac6; /* Teal for links and borders */
            --color-danger: #ff4d4d;    /* Red for AI player O */
            --color-background: #121212;
            --color-surface: #2c2c2e;
        }

        body { 
            display: flex; justify-content: center; align-items: center; 
            min-height: 100vh; margin: 0; padding: 20px 15px;
            background: var(--color-background); font-family: monospace; 
            color: var(--color-text-alt); text-align: center;
        }
        .container { display: flex; flex-direction: column; align-items: center; }

        /* --- Header Section --- */
        h1 { font-size: 2.5em; color: var(--color-primary); }
        p { font-size: 1.1em; max-width: 500px; }
        a.github-button {
            display: inline-block; margin-top: 10px; margin-bottom: 30px;
            padding: 10px 20px; border: 2px solid var(--color-secondary);
            color: var(--color-secondary); text-decoration: none; border-radius: 5px;
        }

        /* --- Game Styles --- */
        .game-wrapper { transition: opacity 0.5s ease-in-out; position: relative; }
        .status { font-size: 1.5em; height: 30px; margin-bottom: 15px;}
        
        .cell { border-radius: 10px; display: flex; justify-content: center; align-items: center; font-weight: bold; transition: opacity 0.3s ease-in-out; cursor: not-allowed; }
        .cell.x { color: var(--color-primary); text-shadow: 0 0 10px var(--color-primary); }
        .cell.o { color: var(--color-danger); text-shadow: 0 0 10px var(--color-danger); }

        .initial-board { display: grid; grid-template-columns: repeat(3, 100px); gap: 10px; }
        .initial-board .cell { width: 100px; height: 100px; font-size: 4em; border: 2px solid var(--color-secondary); box-shadow: 0 0 10px var(--color-secondary); cursor: pointer; }

        .ultimate-board { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; }
        .local-board { 
            position: relative;
            display: grid; grid-template-columns: repeat(3, 60px); grid-template-rows: repeat(3, 60px); gap: 5px; 
            border-radius: 10px; 
            transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
        }
        .local-board.active {
            transform: scale(1.08);
            z-index: 10;
            box-shadow: 0 0 25px var(--color-secondary);
        }
        .local-board .cell { width: 60px; height: 60px; font-size: 2.5em; background: var(--color-surface); }
        .local-board.active .cell:not(.x):not(.o) { cursor: pointer; }
        
        .winner-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            font-size: 8em; font-weight: bold;
            display: flex; justify-content: center; align-items: center;
            pointer-events: none; opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .local-board.won .winner-overlay { opacity: 1; }
        .local-board.won .cell { opacity: 0; }

        .controls { display: flex; gap: 15px; margin-top: 25px; }
        .control-button { padding: 10px 20px; border: 2px solid var(--color-secondary); color: var(--color-secondary); background-color: transparent; font-family: monospace; font-size: 1em; border-radius: 5px; cursor: pointer; }
        
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; z-index: 100; }
        .modal-overlay.visible { opacity: 1; pointer-events: auto; }
        .modal-content { background: var(--color-surface); padding: 30px; border-radius: 10px; max-width: 500px; text-align: left; border: 1px solid var(--color-secondary); }
    </style>
</head>
<body>
    <div class="container">
        <!-- DESCRIPTION RESTORED -->
        <h1>DeveloperCrcodile</h1>
        <p>A developer-in-training, exploring the world of self-hosting and servers. Try to beat my AI in a game of Tic-Tac-Toe below!</p>
        <a href="https://github.com/DeveloperCrcodiles" target="_blank" class="github-button">View My Projects on GitHub</a>

        <h2 class="status"></h2>
        <div id="game-wrapper" class="game-wrapper"></div>
        <div class="controls">
            <button id="restart-button" class="control-button">Restart Game</button>
            <button id="rules-button" class="control-button" style="display: none;">Show Rules</button>
        </div>
    </div>
    
    <div id="rules-modal" class="modal-overlay"> <!-- Rules Modal is unchanged --> </div>

<script>
    const gameWrapper = document.getElementById('game-wrapper');
    const statusDisplay = document.querySelector('.status');
    const restartButton = document.getElementById('restart-button');
    const rulesButton = document.getElementById('rules-button');
    const rulesModal = document.getElementById('rules-modal');
    const closeRulesButton = document.getElementById('close-rules-button');

    const HUMAN = 'X', AI = 'O';
    const WIN_CONDITIONS = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
    let gameActive, isUltimateMode, initialBoardState, localBoards, mainBoardState, activeBoardIndex, initialAiLastMove;
    let aiTurnTimeout = null;

    function initGame(startAsUltimate = false) {
        if (aiTurnTimeout) clearTimeout(aiTurnTimeout);
        gameActive = true;
        isUltimateMode = startAsUltimate;
        statusDisplay.textContent = `Your Turn (${HUMAN})`;
        
        gameWrapper.style.opacity = '0';
        setTimeout(() => {
            gameWrapper.innerHTML = '';
            if (isUltimateMode) {
                setupUltimateBoard(initialBoardState);
            } else {
                setupInitialBoard();
            }
            gameWrapper.style.opacity = '1';
        }, 500);
    }
    
    function setupInitialBoard() {
        if(rulesButton) rulesButton.style.display = 'none';
        const board = document.createElement('div');
        board.className = 'initial-board';
        initialBoardState = Array(9).fill('');
        for (let i=0; i<9; i++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.index = i;
            cell.addEventListener('click', handleInitialClick);
            board.appendChild(cell);
        }
        gameWrapper.appendChild(board);
    }
    
    function setupUltimateBoard(previousGameState) {
        if(rulesButton) rulesButton.style.display = 'inline-block';
        localBoards = Array(9).fill(null).map(() => Array(9).fill(''));
        mainBoardState = Array(9).fill('');
        localBoards[4] = previousGameState;
        mainBoardState[4] = checkWinner(previousGameState, AI) ? AI : 'draw';
        
        const board = document.createElement('div');
        board.className = 'ultimate-board';
        for (let i = 0; i < 9; i++) {
            const localBoardEl = document.createElement('div');
            localBoardEl.className = 'local-board';
            localBoardEl.dataset.boardIndex = i;
            for (let j = 0; j < 9; j++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.boardIndex = i;
                cell.dataset.cellIndex = j;
                cell.addEventListener('click', handleUltimateClick);
                if (i === 4) {
                    cell.textContent = localBoards[i][j];
                    if (localBoards[i][j]) cell.classList.add(localBoards[i][j].toLowerCase());
                }
                localBoardEl.appendChild(cell);
            }
            if (mainBoardState[i]) {
                handleLocalWin(localBoardEl, mainBoardState[i]);
            }
            board.appendChild(localBoardEl);
        }
        gameWrapper.appendChild(board);
        
        activeBoardIndex = initialAiLastMove;
        if(mainBoardState[activeBoardIndex] !== '') {
            activeBoardIndex = null;
        }
        updateActiveBoardHighlights();
    }
    
    function handleLocalWin(localBoardElement, winner) {
        localBoardElement.classList.add('won');
        if (winner !== 'draw') {
            const overlay = document.createElement('div');
            overlay.className = `winner-overlay ${winner.toLowerCase()}`;
            overlay.textContent = winner;
            localBoardElement.appendChild(overlay);
        }
    }
    
    function updateActiveBoardHighlights() {
        document.querySelectorAll('.local-board').forEach(board => {
            const bIndex = parseInt(board.dataset.boardIndex);
            board.classList.remove('active');
            if (!gameActive) return;
            if (mainBoardState[bIndex] === '') {
                if (activeBoardIndex === null || activeBoardIndex === bIndex) {
                    board.classList.add('active');
                }
            }
        });
    }

    function handleInitialClick(e) {
        if (!gameActive) return;
        const index = parseInt(e.target.dataset.index);
        if (initialBoardState[index] !== '') return;
        makeMove(index, HUMAN);
        if (checkWinner(initialBoardState, HUMAN) || initialBoardState.every(c => c !== '')) {
            endGame(true); 
            return;
        }
        gameActive = false;
        statusDisplay.textContent = 'AI is thinking...';
        aiTurnTimeout = setTimeout(initialAiTurn, 700);
    }
    
    function handleUltimateClick(e) {
        if (!gameActive) return;
        const { boardIndex, cellIndex } = e.target.dataset;
        const bIndex = parseInt(boardIndex), cIndex = parseInt(cellIndex);
        if (activeBoardIndex !== null && bIndex !== activeBoardIndex) return;
        if (localBoards[bIndex][cIndex] !== '' || mainBoardState[bIndex] !== '') return;

        makeMove(cIndex, HUMAN, bIndex);
        if (checkUltimateEnd(cIndex, HUMAN)) return;

        gameActive = false;
        statusDisplay.textContent = 'AI is thinking...';
        aiTurnTimeout = setTimeout(ultimateAiTurn, 700);
    }
    
    function makeMove(index, player, boardIndex = null) {
        let cell;
        if (isUltimateMode) {
            localBoards[boardIndex][index] = player;
            cell = gameWrapper.querySelector(`[data-board-index='${boardIndex}'][data-cell-index='${index}']`);
        } else {
            initialBoardState[index] = player;
            cell = gameWrapper.querySelector(`[data-index='${index}']`);
        }
        cell.textContent = player;
        cell.classList.add(player.toLowerCase());
    }

    function endGame(isInitialGame, winner = 'draw') {
        gameActive = false;
        if (isInitialGame) {
            statusDisplay.textContent = "A worthy effort... but inevitable.";
            setTimeout(() => {
                statusDisplay.textContent = "Now, for the real challenge.";
                isUltimateMode = true;
                initGame(true);
            }, 2500);
        } else {
            statusDisplay.textContent = winner === 'draw' ? "It's a Draw!" : `${winner} Wins the Game!`;
            updateActiveBoardHighlights();
        }
    }

    function initialAiTurn() {
        let bestScore = -Infinity, move;
        for (let i = 0; i < 9; i++) {
            if (initialBoardState[i] === '') {
                initialBoardState[i] = AI;
                let score = minimax(initialBoardState, false);
                initialBoardState[i] = '';
                if (score > bestScore) { bestScore = score; move = i; }
            }
        }
        initialAiLastMove = move;
        makeMove(move, AI);
        if (checkWinner(initialBoardState, AI) || initialBoardState.every(c => c !== '')) { 
            endGame(true); 
            return; 
        }
        gameActive = true;
        statusDisplay.textContent = `Your Turn (${HUMAN})`;
    }

    function minimax(board, isMaximizing) {
        if (checkWinner(board, HUMAN)) return -1;
        if (checkWinner(board, AI)) return 1;
        if (board.every(c => c !== '')) return 0;
        let bestScore = isMaximizing ? -Infinity : Infinity;
        for(let i=0; i<9; i++) {
            if(board[i]==='') {
                board[i]= isMaximizing ? AI : HUMAN;
                const score = minimax(board, !isMaximizing);
                board[i]='';
                bestScore = isMaximizing ? Math.max(score, bestScore) : Math.min(score, bestScore);
            }
        }
        return bestScore;
    }
    
    function ultimateAiTurn() {
        const move = findBestUltimateMove();
        if (move) {
            makeMove(move.cellIndex, AI, move.boardIndex);
            if(checkUltimateEnd(move.cellIndex, AI)) return;
        } else { 
            endGame(false, 'draw'); 
        }
        gameActive = true;
        statusDisplay.textContent = `Your Turn (${HUMAN})`;
        // BUG FIX: Highlight is now updated AFTER the AI turn is fully complete.
        updateActiveBoardHighlights();
    }

    function checkUltimateEnd(lastCellIndex, player) {
        const boardIndex = activeBoardIndex;
        // This logic is simplified; it relies on the fact that `handleUltimateClick` ensures the move is valid.
        if (mainBoardState[boardIndex] === '') {
            if (checkWinner(localBoards[boardIndex], player)) {
                mainBoardState[boardIndex] = player;
                handleLocalWin(gameWrapper.querySelector(`[data-board-index='${boardIndex}']`), player);
            } else if (localBoards[boardIndex].every(cell => cell !== '')) {
                mainBoardState[boardIndex] = 'draw';
                handleLocalWin(gameWrapper.querySelector(`[data-board-index='${boardIndex}']`), 'draw');
            }
        }
        
        // This is the core state update that determines the next turn's highlight.
        activeBoardIndex = lastCellIndex;
        if (activeBoardIndex === null || mainBoardState[activeBoardIndex] !== '') {
            activeBoardIndex = null;
        }
        
        if (checkWinner(mainBoardState, player)) { endGame(false, player); return true; }
        if (mainBoardState.every(s => s !== '')) { endGame(false, 'draw'); return true; }

        return false;
    }
    
    function findBestUltimateMove() {
        const moves = getValidMoves();
        if (moves.length === 0) return null;
        moves.sort((a, b) => {
            const priorities = [4, 0, 2, 6, 8, 1, 3, 5, 7];
            return priorities.indexOf(a.cellIndex) - priorities.indexOf(b.cellIndex);
        });
        return moves[0];
    }

    function getValidMoves() {
        const moves = [];
        const targetBoards = (activeBoardIndex === null) 
            ? [0,1,2,3,4,5,6,7,8].filter(i => mainBoardState[i] === '') 
            : [activeBoardIndex];
        for (const bIndex of targetBoards) {
            if(localBoards && localBoards[bIndex]) {
                for(let cIndex=0; cIndex<9; cIndex++) {
                    if(localBoards[bIndex][cIndex] === '') moves.push({boardIndex: bIndex, cellIndex: cIndex});
                }
            }
        }
        return moves;
    }

    function checkWinner(board, player) {
        if(!board) return false;
        return WIN_CONDITIONS.some(combo => combo.every(index => board[index] === player));
    }
    
    if (restartButton) restartButton.addEventListener('click', () => initGame(isUltimateMode));
    if (rulesButton) rulesButton.addEventListener('click', () => rulesModal && rulesModal.classList.add('visible'));
    if (closeRulesButton) closeRulesButton.addEventListener('click', () => rulesModal && rulesModal.classList.remove('visible'));
    
    initGame(false);
</script>
</body>
</html>
